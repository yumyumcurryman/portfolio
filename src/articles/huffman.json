{
    "name": "One-Day Project: Huffman Encoding",
    "datePublished": "April 19, 2022",
    "banner": "huffman.png",
    "blurb": "A little project I made in one day based on the Huffman encoding algorithm I learned in COSC-283: Computer Networks",
    "content": "<h3 class='section-content-header'>The Idea</h3> <p>The main idea for this project was based on the concept of Huffman Encoding that I learned in my COSC-283 Computer Networks class. The goal is to compress data by finding a way to make each character represented in fewer than 8 bits (because a typical ASCII value is represented by 8 bits). The first step to compress data is to first model it. This can include any kind of measuring, pattern finding, or generation of statistics. <div class='media-container'> <img src='https://firebasestorage.googleapis.com/v0/b/portfolio-7ec02.appspot.com/o/huffma%2Fnotes.png?alt=media&token=9a21a3dd-d5b0-44dd-b707-d4c42c47151a' class='reg-image'/> </div> <h3 class='section-content-header'>Generating a Distribution</h3> <p>Because I chose to use Huffman Encoding for this implementation, the first step was to generate a distribution of the letters given as input from the user. This is fairly straight-forward although we do want to remove certain characters such as `\n` or quotations that weren't nested.</p> <div class='media-container'> <img src='https://firebasestorage.googleapis.com/v0/b/portfolio-7ec02.appspot.com/o/huffma%2FScreen%20Shot%202022-04-19%20at%2011.26.58%20AM.png?alt=media&token=c2bd9075-739b-4f46-a11f-97c5d19df75a' class='small-img' /> </div> <h3 class='section-content-header'>Building the Tree</h3> <p>The next step in the process was to actually build the tree itself. Instead of Shannon coding which generates the tree from the top-down, Huffman coding builds the tree from the bottom-up which is a more optimal solution. It does this by picking the two characters with the lowest distribution values. From this data, we create two new child nodes. If one of these nodes matches another that already exists within the tree, we pull that node instead of generating a new one. Using this method, we keep generating nodes until we have one last entry in the distribution which represents the root node of the entire graph.</p> <div class='media-container'> <img src='https://firebasestorage.googleapis.com/v0/b/portfolio-7ec02.appspot.com/o/huffma%2Fcarbon%20(11).png?alt=media&token=122d1080-1c7a-4bda-aeee-ba8974c5d746' class='reg-image' /> </div> <p>After we have the two child nodes, we must combine them into a parent node and set pointers accordingly. It is not only important that the parent has pointers to the children like in a traditional binary tree, but also that the children contain pointers to the parent since the whole project is based on bottom-up tree generation (also comes into play later for graph generation). </p> <div class='media-container'> <img src='https://firebasestorage.googleapis.com/v0/b/portfolio-7ec02.appspot.com/o/huffma%2Fcarbon%20(12).png?alt=media&token=bdd31635-4ada-4a51-a6d6-2833bdde2e86' class='reg-image' /> </div> <h3 class='section-content-header'>Encoding Bits</h3> <p>In order to generate the encoded bit table for a given message, we must traverse the tree for each character while keeping track of whether we move from the parent to the left subtree (0) or the right subtree (1). We do this using recursion and once the last node in the tree has been reached, we can return the bits which now essentially represent the directions to the nodes on the graph.</p> <div class='media-container'> <img src='https://firebasestorage.googleapis.com/v0/b/portfolio-7ec02.appspot.com/o/huffma%2Fcarbon%20(13).png?alt=media&token=97a03e0e-3244-4329-8698-6de5092ca07e' class='reg-image' /> </div> <p>Once we input our message, the tree should generate a list of bit arrays that represent each character. If the length of each individual bit array is less than 8, the character can be represented using less bits than standard and is essentially 'compressed'.</p> <h3 class='section-content-header'>Building the Demo</h3> <p>After spending the first 2 hours on getting the tree structure to generate and encode bits appropriately, the next step was to build a working demo in order to be able to visualize the distribution, bit table, and most importantly a graph view. I decided to build the site as a single-page application using ReactJS. I had to refactor some of the models I had made earlier in the day in order to work with front-end interaction but I was quickly able to get user input to generate the bit values and the letter distribution.</p> <div class='grid_two_one'> <img src='https://firebasestorage.googleapis.com/v0/b/portfolio-7ec02.appspot.com/o/huffma%2FScreen%20Shot%202022-04-19%20at%2012.09.35%20PM.png?alt=media&token=dc6015bb-9336-4492-b470-5bed42a8244f'/> <img src='https://firebasestorage.googleapis.com/v0/b/portfolio-7ec02.appspot.com/o/huffma%2FScreen%20Shot%202022-04-19%20at%2012.09.40%20PM.png?alt=media&token=72f89ac2-fafa-45f3-9166-3b5de09c3f86'/> </div> <h3 class='section-content-header'>Generating the Graph</h3> <p>Besides the actual implementation of the Huffman Encoding algorithm, generating the graph that exists on the web app itself was the most difficult part of this project. Instead of looking for JS packages that support graph generation, for some reason I decided to try and generated Markdown flowcharts using Mermaid as I use Markdown for all kinds of note-taking daily. The first part of this challenge was to have the tree actually generate a Markdown file with the proper Mermaid syntax. In order to generate the nodes through Mermaid, I had to use a UUID system due to lack of formatting of the node content itself. After 30 minutes or so, I got this to output properly.</p> <div class='media-container'> <img src='https://firebasestorage.googleapis.com/v0/b/portfolio-7ec02.appspot.com/o/huffma%2Fcarbon%20(14).png?alt=media&token=5d6aa7b3-95aa-4ebc-a096-c8d1d2ab919b' class='reg-image' /> </div> <p>The last step for graph generation was to actually parse the Markdown file on the client and serve it as an image. This was a bit of a struggle for me and I realized quickly why web graph generation using Markdown may not have been the best idea due to lack of support for embedded Markdown graphs in React components. After troubleshooting some annoying errors with React's `useState()` system, I got this up and running by the end of the day.</p> <div class='media-container'> <img src='https://firebasestorage.googleapis.com/v0/b/portfolio-7ec02.appspot.com/o/huffma%2FScreen%20Shot%202022-04-19%20at%2012.27.36%20PM.png?alt=media&token=3ec8813d-4839-49b1-a0f2-9001fb78d708' class='reg-image' /> </div> <h3 class='section-content-header'>Conclusion</h3> <p>By the end of the day, I had a <a href='https://encoding.micahelias.com'>demo project</a> built in React. While the project is not finished yet (decoding still needs to be implemented), I am pretty happy with the result as it allows you to explore the concept of Huffman Encoding in a much more interactive way.</p>"
}